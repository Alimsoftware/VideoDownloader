# NDK

### Method Declaration of Native stringFromJNI Method

```
public native String stringFromJNI();
```

### Native Implementation of stringFromJNI Method

```
jstring
Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env,
     jobject thiz )
{
    return (*env)->NewStringUTF(env, "Hello from JNI !");
}
```

### The com_example_hellojni_HelloJni.h Header File

```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include < jni.h>
/* Header for class com_example_hellojni_HelloJni */
  
#ifndef _Included_com_example_hellojni_HelloJni
#define _Included_com_example_hellojni_HelloJni
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class: com_example_hellojni_HelloJni
 * Method: stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
  (JNIEnv *, jobject);
  
/*
 * Class: com_example_hellojni_HelloJni
 * Method: unimplementedStringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI
  (JNIEnv *, jobject);
  
#ifdef __cplusplus
}
#endif
#endif
```

### Mandatory Parameters of Native Methods

```
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
  (JNIEnv *, jobject);
```

### Native Instance Method Definition

```
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
  (JNIEnv * env,jobject thiz);
```

### Native Static Method Definition

```
JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
  (JNIEnv * env,jclass clazz);
```

###  New Java String from a Given C String

```
jstring javaString;
javaString = (*env)->NewStringUTF(env, "Hello World!");
```

###  Converting a Java String to C String

```
const jbyte* str;
jboolean isCopy;
  
str = (*env)->GetStringUTFChars(env, javaString, &isCopy);
if (0 != str) {
    printf("Java string: %s", str);
  
    if (JNI_TRUE == isCopy) {
     printf("C string is a copy of the Java string.");
    } else {
     printf("C string points to actual string.");
    }
}
```

### Releasing the C Strings Returned by JNI Functions

```
(*env)->ReleaseStringUTFChars(env, javaString, str);
```

### New Java Array from Native Code

```
jintArray javaArray;
javaArray = (*env)->NewIntArray(env, 10);
if (0 != javaArray) {
    /* You can now use the array. */
}
```

### Getting a Copy of Java Array Region as a C Array

```
jint nativeArray[10];
(*env)->GetIntArrayRegion(env, javaArray, 0, 10, nativeArray);
```

### Committing Back the Changes from C Array to Java Array

```
(*env)->SetIntArrayRegion(env, javaArray, 0, 10, nativeArray);
```

### Getting a Direct Pointer to Java Array Elements

```
jint* nativeDirectArray;
jboolean isCopy;
  
nativeDirectArray = (*env)->GetIntArrayElements(env, javaArray, &isCopy);
```

### Releasing the Direct Pointer to Java Array Elements

```
(*env)->ReleaseIntArrayElements(env, javaArray, nativeDirectArray, 0);
```


### New Byte Buffer Based on the Given C Byte Array

```
unsigned char* buffer = (unsigned char*) malloc(1024);
...
jobject directBuffer;
directBuffer = (*env)->NewDirectByteBuffer(env, buffer, 1024);
```

### Getting the Native Byte Array from the Java Byte Buffer

```
unsigned char* buffer;
buffer = (unsigned char*) (*env)->GetDirectBufferAddress(env,
    directBuffer);
```

### Java Class with Both Static and Instance Fields

```
public class JavaClass {
    /** Instance field */
    private String instanceField = "Instance Field";
  
    /** Static field */
    private static String staticField = "Static Field";
  
    ...
}
```

### Getting the Class from an Object Reference

```
jclass clazz;
clazz = (*env)->GetObjectClass(env, instance);
```

### Getting the Field ID of an Instance Field

```
jfieldID instanceFieldId;
instanceFieldId = (*env)->GetFieldID(env, clazz,
    "instanceField", "Ljava/lang/String;");
```

### Getting the Field ID of a Static Field

```
jfieldID staticFieldId;
staticFieldId = (*env)->GetStaticFieldID(env, clazz,
    "staticField", "Ljava/lang/String;");
```

###  Getting an Instance Field

```
jstring instanceField;
instanceField = (*env)->GetObjectField(env, instance, instanceFieldId);
```

### Getting a Static Field

```
jstring staticField;
staticField = (*env)->GetStaticObjectField(env, clazz, staticFieldId);
```

### Java Class with Both Instance and Static Methods

```
public class JavaClass {
    /**
     * Instance method.
     */
    private String instanceMethod() {
     return "Instance Method";
    }
    /**
     * Static method.
     */
    private static String staticMethod() {
     return "Static Method";
    }
  
    ...
}
```

###  Getting the Method ID of an Instance Method

```
jmethodID instanceMethodId;
instanceMethodId = (*env)->GetMethodID(env, clazz,
    "instanceMethod", "()Ljava/lang/String;");
```


### Getting the Method ID of a Static Method

```
jmethodID staticMethodId;
staticMethodId = (*env)->GetStaticMethodID(env, clazz,
    "staticMethod", "()Ljava/lang/String;");
```


### Calling an Instance Method

```
jstring instanceMethodResult;
instanceMethodResult = (*env)->CallStringMethod(env,
    instance, instanceMethodId);
```

### Calling a Static Method

```
jstring staticMethodResult;
staticMethodResult = (*env)->CallStaticStringMethod(env,
    clazz, staticMethodId);


Java Type	Signature
Boolean	Z
Byte	B
Char	C
Short	S
Int	I
Long	J
Float	F
Double	D
fully-qualified-class	Lfully-qualified-class;
type[]	[type
method type	(arg-type)ret-type

```

### Java Example That Throws an Exception

```

public class JavaClass {
    /**
     * Throwing method.
     */
    private void throwingMethod() throws NullPointerException {
     throw new NullPointerException("Null pointer");
    }
    /**
     * Access methods native method.
     */
    private native void accessMethods();
}
```


### Exception Handling in Native Code

```
jthrowable ex;
...
(*env)->CallVoidMethod(env, instance, throwingMethodId);
ex = (*env)->ExceptionOccurred(env);
if (0 != ex) {
    (*env)->ExceptionClear(env);
  
    /* Exception handler. */
}
```

### Throwing an Exception from Native Code

```
jclass clazz;
...
clazz = (*env)->FindClass(env, "java/lang/NullPointerException");
if (0 ! = clazz) {
    (*env)->ThrowNew(env, clazz, "Exception message.");
}
```


### Deleting a Local Reference

```
jclass clazz;
clazz = (*env)->FindClass(env, "java/lang/String");
...
(*env)->DeleteLocalRef(env, clazz);
```

### New Global Reference from a Given Local Reference

```
jclass localClazz;
jclass globalClazz;
...
localClazz = (*env)->FindClass(env, "java/lang/String");
globalClazz = (*env)->NewGlobalRef(env, localClazz);
...
(*env)->DeleteLocalRef(env, localClazz);
```

### Deleting a Global Reference

```
(*env)->DeleteGlobalRef(env, globalClazz);
```

### New Weak Global Reference from a Given Local Reference

```
jclass weakGlobalClazz;
weakGlobalClazz = (*env)->NewWeakGlobalRef(env, localClazz);
```

### Checking if Weak Global Reference is Still Valid

```
if (JNI_FALSE == (*env)->IsSameObject(env, weakGlobalClazz, NULL)) {
    /* Object is still live and can be used. */
} else {
    /* Object is garbage collected and cannot be used. */
}
```

### Deleting a Weak Global Reference

```
(*env)->DeleteWeakGlobalRef(env, weakGlobalClazz);
```

### Java Synchronized Code Block

```
synchronized(obj) {
    /* Synchronized thread-safe code block. */
}
```

### Native Equivalent of Java Synchronized Code Block

```
if (JNI_OK == (*env)->MonitorEnter(env, obj)) {
    /* Error handling. */
}
  
/* Synchronized thread-safe code block. */
  
if (JNI_OK == (*env)->MonitorExit(env, obj)) {
    /* Error handling. */
}
```

### Attaching and Detaching the Current Thread to the Virtual Machine

```
JavaVM* cachedJvm;
...
JNIEnv* env;
...
/* Attach the current thread to virtual machine. */
(*cachedJvm)->AttachCurrentThread(cachedJvm, &env, NULL);
  
/* Thread can communicate with the Java application
  using the JNIEnv interface. */
  
/* Detach the current thread from virtual machine. */
(*cachedJvm)->DetachCurrentThread(cachedJvm);
```

## Bitwise Operators

**Shift**: The bitwise shift operators shift the contents of an integer variable by a specified number of bits to the left or right. The >> operator shifts bits to the right, and the << operator shifts bits to the left.|

**∼**: The bitwise complement operator is a unary operator that inverts the bits in its operand, so 1 becomes 0, and 0 becomes 1.

**&**: The bitwise AND operator ANDs corresponding bits in its operands. If the corresponding bits are both 1, then the resulting bit is 1; otherwise, it’s 0.

**^**: The bitwise exclusive OR operator or XOR operator exclusive-ORs corresponding bits in its operands. If the corresponding bits are different, then the result is 1. If the corresponding bits are the same, the result is 0.

**|**: The bitwise OR operator ORs corresponding bits in its operands. If either bit is 1, then the result is 1. If both bits are 0, then the result is 0.


## 数组


- https://learning.oreilly.com/search/?query=*&extended_publisher_data=true&highlight=true&include_assessments=false&include_case_studies=true&include_courses=true&include_playlists=true&include_collections=true&include_notebooks=true&include_sandboxes=true&include_scenarios=true&is_academic_institution_account=false&source=user&formats=book&topics=C%2B%2B&sort=publication_date&facet_json=true&json_facets=true&page=0&include_facets=true&include_practice_exams=true
